diff --git a/Makefile b/Makefile
index 2083611..390be94 100644
--- a/Makefile
+++ b/Makefile
@@ -12,7 +12,20 @@ endif
 LIBUSB_FLAGS := `pkg-config --cflags --libs libusb-1.0`
 
 CFLAGS := -std=c11 -fPIC -pedantic -DRS_USE_$(BACKEND)_BACKEND $(LIBUSB_FLAGS) 
-CXXFLAGS := -std=c++11 -fPIC -pedantic -mssse3 -Ofast -Wno-missing-field-initializers
+CXXFLAGS := -std=c++11 -fPIC -pedantic -Ofast -Wno-missing-field-initializers
+
+# Use SSE if feature is available - cpuinfo has features such as SSE on x86, NEON on ARM
+cpufeature = $(if $(findstring $(1),$(shell cat /proc/cpuinfo)),$(2))
+PARAMS_SSE = $(call cpufeature,sse,-msse) $(call cpufeature,sse2,-msse2) $(call cpufeature,sse3,-msse3) \
+ $(call cpufeature,sse4,-msse4) $(call cpufeature,sse4_1,-msse4.1) \
+$(call cpufeature,sse4_2,-msse4.2) 
+
+ifneq ($(strip $(PARAMS_SSE)),)
+CFLAGS += $(PARAMS_SSE)
+CXXFLAGS += $(PARAMS_SSE)
+endif
+
+
 CXXFLAGS += -Wno-switch -Wno-multichar -DRS_USE_$(BACKEND)_BACKEND $(LIBUSB_FLAGS) 
 
 # Add specific include paths for OSX
diff --git a/librealsense.qtcreator/realsense.pro b/librealsense.qtcreator/realsense.pro
index 8a16690..2fe7ed5 100644
--- a/librealsense.qtcreator/realsense.pro
+++ b/librealsense.qtcreator/realsense.pro
@@ -9,7 +9,7 @@ INCLUDEPATH += ../include
 CONFIG += link_pkgconfig
 PKGCONFIG += libusb-1.0
 LIBS += -pthread
-QMAKE_CXXFLAGS += -std=c++11 -fPIC -pedantic -mssse3
+QMAKE_CXXFLAGS += -std=c++11 -fPIC -pedantic
 QMAKE_CXXFLAGS += -Wno-missing-field-initializers -Wno-switch -Wno-multichar
 QMAKE_CXXFLAGS += -DRS_USE_V4L2_BACKEND
 
diff --git a/src/image.cpp b/src/image.cpp
index d19d29e..2ee5471 100644
--- a/src/image.cpp
+++ b/src/image.cpp
@@ -8,7 +8,11 @@
 #include <cmath>
 #include <algorithm>
 
-#include <tmmintrin.h> // For SSE3 intrinsics used in unpack_yuy2_sse
+#ifndef __arm__
+	#include <tmmintrin.h> // For SSE3 intrinsics used in unpack_yuy2_sse
+#else
+	inline uint8_t clamp_byte(int v) { return v < 0 ? 0 : v > 255 ? 255 : v; }
+#endif
 
 #pragma pack(push, 1) // All structs in this file are assumed to be byte-packed
 namespace rsimpl
@@ -64,6 +68,7 @@ namespace rsimpl
     // It is expected that all branching outside of the loop control variable will be removed due to constant-folding.
     template<rs_format FORMAT> void unpack_yuy2(byte * const d [], const byte * s, int n)
     {
+#ifndef __arm__
         assert(n % 16 == 0); // All currently supported color resolutions are multiples of 16 pixels. Could easily extend support to other resolutions by copying final n<16 pixels into a zero-padded buffer and recursively calling self for final iteration.
         auto src = reinterpret_cast<const __m128i *>(s);
         auto dst = reinterpret_cast<__m128i *>(d[0]);
@@ -205,7 +210,36 @@ namespace rsimpl
                     _mm_storeu_si128(dst++, _mm_alignr_epi8(bgr3, bgr2, 12));                
                 }
             }
-        }    
+        }
+#else
+		// Currently only YUY2 to RGB8 is implemented for ARM.
+		if (FORMAT == RS_FORMAT_RGB8)
+		{
+			auto ptrIn = reinterpret_cast<const uint8_t *>(s);
+			auto ptrOut = reinterpret_cast<uint8_t *>(d[0]);
+
+			for (int i = 0; i < n / 2; ++i)
+			{
+				uint8_t y0 = ptrIn[0];
+				uint8_t u0 = ptrIn[1];
+				uint8_t y1 = ptrIn[2];
+				uint8_t v0 = ptrIn[3];
+				ptrIn += 4;
+				int c = y0 - 16;
+				int d = u0 - 128;
+				int e = v0 - 128;
+				ptrOut[0] = clamp_byte((128 + 298 * c + 409 * e) >> 8); // red
+				ptrOut[1] = clamp_byte((128 + 298 * c - 100 * d - 208 * e) >> 8); // green
+				ptrOut[2] = clamp_byte((128 + 298 * c + 516 * d) >> 8); // blue
+				c = y1 - 16;
+				ptrOut[3] = clamp_byte((128 + 298 * c + 409 * e) >> 8); // red
+				ptrOut[4] = clamp_byte((128 + 298 * c - 100 * d - 208 * e) >> 8); // green
+				ptrOut[5] = clamp_byte((128 + 298 * c + 516 * d) >> 8); // blue
+				ptrOut += 6;
+			}
+		}
+#endif // !__arm__
+    
     }
     
     //////////////////////////////////////
diff --git a/src/uvc-v4l2.cpp b/src/uvc-v4l2.cpp
index 1cde638..4d69df6 100644
--- a/src/uvc-v4l2.cpp
+++ b/src/uvc-v4l2.cpp
@@ -247,15 +247,7 @@ namespace rsimpl
                         buf.index = i;
                         if(xioctl(fd, VIDIOC_QBUF, &buf) < 0) throw_error("VIDIOC_QBUF");
                     }
-
                     v4l2_buf_type type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-                    for(int i=0; i<10; ++i)
-                    {
-                        if(xioctl(fd, VIDIOC_STREAMON, &type) < 0)
-                        {
-                            std::this_thread::sleep_for(std::chrono::milliseconds(100));
-                        }
-                    }
                     if(xioctl(fd, VIDIOC_STREAMON, &type) < 0) throw_error("VIDIOC_STREAMON");
 
                     is_capturing = true;
